import * as fs from 'fs/promises';
import * as path from 'path';
import { DetectedComponent, ProcessedStyles } from '../types/index.js';

export async function writeComponents(
  outputDir: string,
  components: DetectedComponent[],
  styles: ProcessedStyles
): Promise<void> {
  const componentsDir = path.join(outputDir, 'src/components');
  await fs.mkdir(componentsDir, { recursive: true });

  // Sort components by dependencies to ensure proper import order
  const sortedComponents = sortComponentsByDependencies(components);

  // Write each component file
  for (const component of sortedComponents) {
    const fileName = `${component.name}.tsx`;
    const filePath = path.join(componentsDir, fileName);
    const code = enhanceComponentCode(component, styles);
    await fs.writeFile(filePath, code, 'utf-8');
  }

  // Create index.ts with all exports
  const indexContent = generateComponentIndex(sortedComponents);
  await fs.writeFile(
    path.join(componentsDir, 'index.ts'),
    indexContent,
    'utf-8'
  );
}

function sortComponentsByDependencies(
  components: DetectedComponent[]
): DetectedComponent[] {
  const sorted: DetectedComponent[] = [];
  const visited = new Set<string>();
  const visiting = new Set<string>();

  function visit(component: DetectedComponent) {
    if (visited.has(component.name)) return;
    if (visiting.has(component.name)) {
      // Circular dependency - just add it
      sorted.push(component);
      visited.add(component.name);
      return;
    }

    visiting.add(component.name);

    // Visit dependencies first
    if (component.dependencies) {
      for (const dep of component.dependencies) {
        // Only handle local component dependencies
        if (dep.startsWith('.') || dep.startsWith('/')) {
          const depComponent = components.find((c) =>
            dep.includes(c.name)
          );
          if (depComponent) {
            visit(depComponent);
          }
        }
      }
    }

    visiting.delete(component.name);
    visited.add(component.name);
    sorted.push(component);
  }

  for (const component of components) {
    visit(component);
  }

  return sorted;
}

function enhanceComponentCode(
  component: DetectedComponent,
  styles: ProcessedStyles
): string {
  let code = component.code;

  // Ensure proper imports
  code = ensureImports(code, component);

  // Apply Tailwind classes from style mapping
  code = applyTailwindClasses(code, component.name, styles);

  // Format code with proper indentation
  code = formatCode(code);

  // Add file header comment
  const header = `/**
 * ${component.name}
 * Generated by site-cloner
 */

`;

  return header + code;
}

function ensureImports(code: string, component: DetectedComponent): string {
  const imports = new Set<string>();

  // Always import React if not present
  if (!code.includes('import React') && !code.includes("import 'react'")) {
    imports.add("import React from 'react';");
  }

  // Check for hooks usage
  const hookPatterns = [
    { hook: 'useState', pattern: /useState/ },
    { hook: 'useEffect', pattern: /useEffect/ },
    { hook: 'useRef', pattern: /useRef/ },
    { hook: 'useMemo', pattern: /useMemo/ },
    { hook: 'useCallback', pattern: /useCallback/ },
    { hook: 'useContext', pattern: /useContext/ },
    { hook: 'useReducer', pattern: /useReducer/ },
  ];

  const usedHooks: string[] = [];
  for (const { hook, pattern } of hookPatterns) {
    if (pattern.test(code) && !code.includes(`import { ${hook}`)) {
      usedHooks.push(hook);
    }
  }

  if (usedHooks.length > 0) {
    imports.add(`import { ${usedHooks.join(', ')} } from 'react';`);
  }

  // Check for framer-motion
  if (
    (code.includes('motion.') || code.includes('<motion')) &&
    !code.includes("from 'framer-motion'")
  ) {
    imports.add("import { motion } from 'framer-motion';");
  }

  // Check for animation imports
  if (
    code.includes('AnimatePresence') &&
    !code.includes('AnimatePresence')
  ) {
    imports.add(
      "import { motion, AnimatePresence } from 'framer-motion';"
    );
  }

  // Add imports to the beginning of the file
  if (imports.size > 0) {
    const importLines = Array.from(imports).join('\n');
    code = importLines + '\n\n' + code;
  }

  return code;
}

function mergeClassName(code: string, selector: string, newClasses: string): string {
  // Pattern to match element with existing className
  const withClassRegex = new RegExp(
    `(<${selector}[^>]*className=")([^"]*)(")`,
    'g'
  );

  // Check if element already has className - need to reset regex
  const testRegex = new RegExp(`(<${selector}[^>]*className=")([^"]*)(")`, 'g');
  if (testRegex.test(code)) {
    // Merge: append new classes to existing
    return code.replace(withClassRegex, (match, prefix, existing, suffix) => {
      const merged = [...new Set([...existing.split(' ').filter(c => c), ...newClasses.split(' ').filter(c => c)])].join(' ');
      return `${prefix}${merged}${suffix}`;
    });
  }

  // No existing className - add it
  const withoutClassRegex = new RegExp(`(<${selector})(\\s|>)`, 'g');
  return code.replace(withoutClassRegex, `$1 className="${newClasses}"$2`);
}

function applyTailwindClasses(
  code: string,
  componentName: string,
  styles: ProcessedStyles
): string {
  // This is a simplified version - in production you'd want more sophisticated class injection
  // For now, we'll assume the code already has className attributes

  // If there are specific class mappings in styles.classMap, try to apply them
  if (styles.classMap && styles.classMap instanceof Map) {
    for (const [selector, classes] of styles.classMap) {
      // This is a naive approach - you might want to use AST parsing for better results
      // Try to find matching elements and add classes
      const classString = Array.isArray(classes) ? classes.map(c => typeof c === 'string' ? c : (c && typeof c === 'object' && 'className' in c ? c.className : String(c))).join(' ') : '';

    // Look for common patterns and inject classes
      if (selector.includes(componentName.toLowerCase())) {
        // Use mergeClassName to avoid duplicate className attributes
        code = mergeClassName(code, 'div', classString);
      }
    }
  }

  return code;
}

function formatCode(code: string): string {
  // Basic code formatting
  // In production, you'd use prettier or a proper formatter

  // Remove multiple blank lines
  code = code.replace(/\n\s*\n\s*\n/g, '\n\n');

  // Ensure consistent spacing around braces
  code = code.replace(/\{\s+/g, '{ ');
  code = code.replace(/\s+\}/g, ' }');

  return code.trim() + '\n';
}

function generateComponentIndex(components: DetectedComponent[]): string {
  const exports = components
    .map((c) => `export { default as ${c.name} } from './${c.name}';`)
    .join('\n');

  return `/**
 * Component exports
 * Generated by site-cloner
 */

${exports}
`;
}

export function generateUtilityClass(name: string, code: string): string {
  return `/**
 * ${name}
 * Utility function
 */

${code}
`;
}

export async function writeUtilities(
  outputDir: string,
  utilities: Record<string, string>
): Promise<void> {
  const utilsDir = path.join(outputDir, 'src/utils');
  await fs.mkdir(utilsDir, { recursive: true });

  for (const [name, code] of Object.entries(utilities)) {
    const fileName = `${name}.ts`;
    const filePath = path.join(utilsDir, fileName);
    const formattedCode = generateUtilityClass(name, code);
    await fs.writeFile(filePath, formattedCode, 'utf-8');
  }

  // Create index.ts
  const indexContent = Object.keys(utilities)
    .map((name) => `export * from './${name}';`)
    .join('\n');

  await fs.writeFile(
    path.join(utilsDir, 'index.ts'),
    indexContent + '\n',
    'utf-8'
  );
}

export async function writeHooks(
  outputDir: string,
  hooks: Record<string, string>
): Promise<void> {
  const hooksDir = path.join(outputDir, 'src/hooks');
  await fs.mkdir(hooksDir, { recursive: true });

  for (const [name, code] of Object.entries(hooks)) {
    const fileName = `${name}.ts`;
    const filePath = path.join(hooksDir, fileName);
    const formattedCode = `/**
 * ${name}
 * Custom React hook
 */

${code}
`;
    await fs.writeFile(filePath, formattedCode, 'utf-8');
  }

  // Create index.ts
  const indexContent = Object.keys(hooks)
    .map((name) => `export * from './${name}';`)
    .join('\n');

  await fs.writeFile(
    path.join(hooksDir, 'index.ts'),
    indexContent + '\n',
    'utf-8'
  );
}

export interface FormatOptions {
  indentSize?: number;
  useTabs?: boolean;
  singleQuote?: boolean;
  semicolons?: boolean;
  trailingComma?: boolean;
}

export function formatTypeScript(
  code: string,
  options: FormatOptions = {}
): string {
  const {
    indentSize = 2,
    useTabs = false,
    singleQuote = true,
    semicolons = true,
    trailingComma = true,
  } = options;

  let formatted = code;

  // Basic formatting operations
  formatted = removeExtraWhitespace(formatted);
  formatted = normalizeLineBreaks(formatted);
  formatted = formatImports(formatted);
  formatted = formatQuotes(formatted, singleQuote);
  formatted = formatSemicolons(formatted, semicolons);
  formatted = indentCode(formatted, indentSize, useTabs);

  return formatted;
}

function removeExtraWhitespace(code: string): string {
  // Remove trailing whitespace
  code = code.replace(/[ \t]+$/gm, '');

  // Remove multiple consecutive blank lines
  code = code.replace(/\n{3,}/g, '\n\n');

  return code;
}

function normalizeLineBreaks(code: string): string {
  // Convert all line breaks to \n
  return code.replace(/\r\n/g, '\n');
}

function formatImports(code: string): string {
  // Sort imports alphabetically
  const lines = code.split('\n');
  const imports: string[] = [];
  const rest: string[] = [];
  let inImportBlock = true;

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('import ')) {
      imports.push(line);
    } else if (trimmed === '') {
      if (inImportBlock && imports.length > 0) {
        inImportBlock = false;
      }
      rest.push(line);
    } else {
      inImportBlock = false;
      rest.push(line);
    }
  }

  // Sort imports: React first, then third-party, then local
  const reactImports = imports.filter((i) => i.includes("from 'react"));
  const thirdPartyImports = imports.filter(
    (i) => !i.includes("from 'react") && !i.includes("from '.")
  );
  const localImports = imports.filter((i) => i.includes("from '."));

  const sortedImports = [
    ...reactImports.sort(),
    ...thirdPartyImports.sort(),
    ...localImports.sort(),
  ];

  if (sortedImports.length > 0) {
    return sortedImports.join('\n') + '\n\n' + rest.join('\n');
  }

  return code;
}

function formatQuotes(code: string, useSingleQuote: boolean): string {
  if (!useSingleQuote) return code;

  // Convert double quotes to single quotes (but not in JSX attributes)
  // This is a simplified version - a full implementation would use AST
  let inJSX = false;
  let result = '';

  for (let i = 0; i < code.length; i++) {
    const char = code[i];
    const prev = code[i - 1];
    const next = code[i + 1];

    // Detect JSX
    if (char === '<' && /[A-Z]/.test(next)) {
      inJSX = true;
    } else if (char === '>' && prev !== '=') {
      inJSX = false;
    }

    // Convert quotes
    if (char === '"' && !inJSX) {
      result += "'";
    } else {
      result += char;
    }
  }

  return result;
}

function formatSemicolons(code: string, useSemicolons: boolean): string {
  if (!useSemicolons) {
    // Remove semicolons (simplified)
    return code.replace(/;(\s*\n)/g, '$1');
  }

  return code;
}

function indentCode(
  code: string,
  indentSize: number,
  useTabs: boolean
): string {
  const indent = useTabs ? '\t' : ' '.repeat(indentSize);
  const lines = code.split('\n');
  let level = 0;
  const result: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Adjust indentation based on brackets
    const openBrackets = (line.match(/[{[(]/g) || []).length;
    const closeBrackets = (line.match(/[}\])]/g) || []).length;

    // Decrease level if line starts with closing bracket
    if (line.startsWith('}') || line.startsWith(']') || line.startsWith(')')) {
      level = Math.max(0, level - 1);
    }

    // Add indented line
    if (line.length > 0) {
      result.push(indent.repeat(level) + line);
    } else {
      result.push('');
    }

    // Increase level for next line
    level += openBrackets - closeBrackets;
    level = Math.max(0, level);
  }

  return result.join('\n');
}

export function formatJSX(code: string, options: FormatOptions = {}): string {
  // Specialized JSX formatting
  return formatTypeScript(code, options);
}

export function addComponentHeader(
  componentName: string,
  description?: string
): string {
  const descLine = description ? `\n * ${description}` : '';
  return `/**
 * ${componentName}${descLine}
 * Generated by site-cloner
 */

`;
}

export function formatComponentExport(
  componentName: string,
  isDefault: boolean = true
): string {
  if (isDefault) {
    return `\nexport default ${componentName};\n`;
  }
  return `\nexport { ${componentName} };\n`;
}

export function wrapInFragment(jsx: string): string {
  return `<>\n${jsx}\n</>`;
}

export function ensureNewlineAtEnd(code: string): string {
  return code.endsWith('\n') ? code : code + '\n';
}
